//! Calibre compatibility tests
//!
//! Tests our library against reference EPUB/AZW3 files generated by Calibre.
//! This ensures we can correctly read files produced by Calibre and that our
//! output is compatible with Calibre's expectations.

use std::collections::HashSet;
use std::path::Path;

use boko::{read_epub, read_mobi, write_epub, write_mobi, Book};
use tempfile::TempDir;

const FIXTURES_DIR: &str = concat!(env!("CARGO_MANIFEST_DIR"), "/tests/fixtures");

fn fixture_path(name: &str) -> String {
    format!("{}/{}", FIXTURES_DIR, name)
}

// ============================================================================
// EPUB Reading Tests (Calibre-generated EPUBs)
// ============================================================================

#[test]
fn test_read_calibre_simple_epub() {
    let path = fixture_path("simple.epub");
    let book = read_epub(&path).expect("Failed to read simple.epub");

    // Verify metadata
    assert_eq!(book.metadata.title, "Simple Test Book");
    assert!(
        book.metadata.authors.contains(&"Test Author".to_string()),
        "Authors: {:?}",
        book.metadata.authors
    );
    assert_eq!(book.metadata.language, "en");

    // Verify structure
    assert!(!book.spine.is_empty(), "Spine should not be empty");
    assert!(!book.toc.is_empty(), "TOC should not be empty");

    // Verify TOC has expected entries (simple.html has h2#page1 and h2#page2)
    let toc_titles: Vec<_> = book.toc.iter().map(|e| e.title.as_str()).collect();
    assert!(
        toc_titles.iter().any(|t| t.contains("simple") || t.contains("page")),
        "TOC titles: {:?}",
        toc_titles
    );

    // Verify resources exist
    assert!(!book.resources.is_empty(), "Resources should not be empty");

    // Check that spine items reference existing resources
    for item in &book.spine {
        assert!(
            book.resources.contains_key(&item.href),
            "Spine item {} not found in resources",
            item.href
        );
    }
}

#[test]
fn test_read_calibre_split_epub() {
    let path = fixture_path("split.epub");
    let book = read_epub(&path).expect("Failed to read split.epub");

    assert_eq!(book.metadata.title, "Split Test Book");
    assert!(!book.spine.is_empty());
    assert!(!book.toc.is_empty());

    // Split book should have multiple spine items
    println!("Split book has {} spine items", book.spine.len());
}

#[test]
fn test_read_calibre_quickstart_epub() {
    let path = fixture_path("eng.epub");
    let book = read_epub(&path).expect("Failed to read eng.epub (Calibre Quick Start)");

    // Quick Start guide has rich content
    assert!(!book.metadata.title.is_empty());
    assert!(!book.spine.is_empty());
    assert!(!book.toc.is_empty());

    // Should have images
    let has_images = book.resources.values().any(|r| r.media_type.starts_with("image/"));
    assert!(has_images, "Quick Start should have images");

    println!("Quick Start: {} spine items, {} resources", book.spine.len(), book.resources.len());
}

// ============================================================================
// AZW3 Reading Tests (Calibre-generated AZW3s)
// ============================================================================

#[test]
fn test_read_calibre_simple_azw3() {
    let path = fixture_path("simple.azw3");
    let book = read_mobi(&path).expect("Failed to read simple.azw3");

    // Verify metadata
    assert_eq!(book.metadata.title, "Simple Test Book");
    assert!(
        book.metadata.authors.contains(&"Test Author".to_string()),
        "Authors: {:?}",
        book.metadata.authors
    );

    // Verify structure
    assert!(!book.spine.is_empty(), "Spine should not be empty");
    assert!(!book.toc.is_empty(), "TOC should not be empty");

    println!(
        "AZW3 simple: {} spine items, {} TOC entries",
        book.spine.len(),
        book.toc.len()
    );
}

#[test]
fn test_read_calibre_split_azw3() {
    let path = fixture_path("split.azw3");
    let book = read_mobi(&path).expect("Failed to read split.azw3");

    assert_eq!(book.metadata.title, "Split Test Book");
    assert!(!book.spine.is_empty());
    assert!(!book.toc.is_empty());

    println!(
        "AZW3 split: {} spine items, {} TOC entries",
        book.spine.len(),
        book.toc.len()
    );
}

// ============================================================================
// EPUB/AZW3 Cross-format Tests
// ============================================================================

#[test]
fn test_epub_azw3_metadata_equivalence() {
    // Read both formats of the same book
    let epub = read_epub(&fixture_path("simple.epub")).expect("Failed to read EPUB");
    let azw3 = read_mobi(&fixture_path("simple.azw3")).expect("Failed to read AZW3");

    // Metadata should match
    assert_eq!(epub.metadata.title, azw3.metadata.title);
    assert_eq!(epub.metadata.authors, azw3.metadata.authors);
    // Language might differ slightly in format
}

// ============================================================================
// Round-trip Tests
// ============================================================================

#[test]
fn test_epub_roundtrip_preserves_structure() {
    let original = read_epub(&fixture_path("simple.epub")).expect("Failed to read original");

    let temp_dir = TempDir::new().expect("Failed to create temp dir");
    let output_path = temp_dir.path().join("roundtrip.epub");

    write_epub(&original, &output_path).expect("Failed to write EPUB");
    let roundtrip = read_epub(&output_path).expect("Failed to read roundtrip");

    // Verify metadata preserved
    assert_eq!(original.metadata.title, roundtrip.metadata.title);
    assert_eq!(original.metadata.authors, roundtrip.metadata.authors);

    // Verify spine count preserved
    assert_eq!(original.spine.len(), roundtrip.spine.len());

    // Verify TOC count preserved
    assert_eq!(original.toc.len(), roundtrip.toc.len());

    // Verify resources preserved (by href)
    let original_hrefs: HashSet<_> = original.resources.keys().collect();
    let roundtrip_hrefs: HashSet<_> = roundtrip.resources.keys().collect();
    assert_eq!(
        original_hrefs, roundtrip_hrefs,
        "Resources should be preserved"
    );
}

#[test]
fn test_azw3_to_epub_conversion() {
    let azw3 = read_mobi(&fixture_path("simple.azw3")).expect("Failed to read AZW3");

    let temp_dir = TempDir::new().expect("Failed to create temp dir");
    let epub_path = temp_dir.path().join("converted.epub");

    write_epub(&azw3, &epub_path).expect("Failed to write EPUB");
    let epub = read_epub(&epub_path).expect("Failed to read converted EPUB");

    // Verify metadata preserved
    assert_eq!(azw3.metadata.title, epub.metadata.title);
    assert_eq!(azw3.metadata.authors, epub.metadata.authors);

    // Content should be present
    assert!(!epub.spine.is_empty());
    assert!(!epub.resources.is_empty());
}

#[test]
fn test_epub_to_azw3_conversion() {
    let epub = read_epub(&fixture_path("simple.epub")).expect("Failed to read EPUB");

    let temp_dir = TempDir::new().expect("Failed to create temp dir");
    let azw3_path = temp_dir.path().join("converted.azw3");

    write_mobi(&epub, &azw3_path).expect("Failed to write AZW3");
    let azw3 = read_mobi(&azw3_path).expect("Failed to read converted AZW3");

    // Verify metadata preserved
    assert_eq!(epub.metadata.title, azw3.metadata.title);
    assert_eq!(epub.metadata.authors, azw3.metadata.authors);

    // Content should be present
    assert!(!azw3.spine.is_empty());
}

#[test]
fn test_full_roundtrip_azw3_epub_azw3() {
    // AZW3 → EPUB → AZW3
    let original = read_mobi(&fixture_path("simple.azw3")).expect("Failed to read original AZW3");

    let temp_dir = TempDir::new().expect("Failed to create temp dir");

    // AZW3 → EPUB
    let epub_path = temp_dir.path().join("step1.epub");
    write_epub(&original, &epub_path).expect("Failed to write EPUB");
    let epub = read_epub(&epub_path).expect("Failed to read EPUB");

    // EPUB → AZW3
    let azw3_path = temp_dir.path().join("step2.azw3");
    write_mobi(&epub, &azw3_path).expect("Failed to write AZW3");
    let final_azw3 = read_mobi(&azw3_path).expect("Failed to read final AZW3");

    // Verify metadata survived the journey
    assert_eq!(original.metadata.title, final_azw3.metadata.title);
    assert_eq!(original.metadata.authors, final_azw3.metadata.authors);
}

// ============================================================================
// Content Verification Tests
// ============================================================================

#[test]
fn test_epub_content_extraction() {
    let book = read_epub(&fixture_path("simple.epub")).expect("Failed to read EPUB");

    // Get all text content
    let mut total_text = String::new();
    for (href, resource) in &book.resources {
        if resource.media_type == "application/xhtml+xml" {
            let content = String::from_utf8_lossy(&resource.data);
            total_text.push_str(&content);
        }
    }

    // The simple.html has specific text we can verify
    assert!(
        total_text.contains("pleasure rationally") || total_text.contains("master-builder"),
        "Expected content not found"
    );
}

#[test]
fn test_azw3_content_extraction() {
    let book = read_mobi(&fixture_path("simple.azw3")).expect("Failed to read AZW3");

    // Get all text content
    let mut total_text = String::new();
    for (href, resource) in &book.resources {
        if resource.media_type == "application/xhtml+xml" {
            let content = String::from_utf8_lossy(&resource.data);
            total_text.push_str(&content);
        }
    }

    // The simple.html has specific text we can verify
    assert!(
        total_text.contains("pleasure") || total_text.contains("master-builder"),
        "Expected content not found in AZW3"
    );
}

// ============================================================================
// Link Validation Tests (like Calibre's check_links)
// ============================================================================

fn check_links(book: &Book) -> Vec<String> {
    let mut errors = Vec::new();
    let resource_hrefs: HashSet<_> = book.resources.keys().cloned().collect();

    // Check spine references
    for item in &book.spine {
        if !resource_hrefs.contains(&item.href) {
            errors.push(format!("Spine item {} not found in resources", item.href));
        }
    }

    // Check TOC references (basic check - href exists)
    for entry in &book.toc {
        let href_base = entry.href.split('#').next().unwrap_or(&entry.href);
        if !href_base.is_empty() && !resource_hrefs.iter().any(|r| r.ends_with(href_base)) {
            // Allow for different path prefixes
            let found = resource_hrefs.iter().any(|r| {
                let r_base = r.rsplit('/').next().unwrap_or(r);
                r_base == href_base || r.ends_with(href_base)
            });
            if !found {
                errors.push(format!("TOC entry {} not found in resources", entry.href));
            }
        }
    }

    errors
}

#[test]
fn test_epub_links_valid() {
    let book = read_epub(&fixture_path("simple.epub")).expect("Failed to read EPUB");
    let errors = check_links(&book);
    assert!(
        errors.is_empty(),
        "Link validation errors: {:?}",
        errors
    );
}

#[test]
fn test_epub_roundtrip_links_valid() {
    let original = read_epub(&fixture_path("simple.epub")).expect("Failed to read EPUB");

    let temp_dir = TempDir::new().expect("Failed to create temp dir");
    let output_path = temp_dir.path().join("roundtrip.epub");

    write_epub(&original, &output_path).expect("Failed to write EPUB");
    let roundtrip = read_epub(&output_path).expect("Failed to read roundtrip");

    let errors = check_links(&roundtrip);
    assert!(
        errors.is_empty(),
        "Roundtrip link validation errors: {:?}",
        errors
    );
}

// ============================================================================
// Compare with Calibre output
// ============================================================================

#[test]
fn test_our_output_matches_calibre_structure() {
    // Read Calibre-generated EPUB
    let calibre_book = read_epub(&fixture_path("simple.epub")).expect("Failed to read Calibre EPUB");

    // Write it with our library
    let temp_dir = TempDir::new().expect("Failed to create temp dir");
    let our_path = temp_dir.path().join("our_output.epub");
    write_epub(&calibre_book, &our_path).expect("Failed to write EPUB");

    // Read our output
    let our_book = read_epub(&our_path).expect("Failed to read our EPUB");

    // Compare structures
    assert_eq!(calibre_book.metadata.title, our_book.metadata.title);
    assert_eq!(calibre_book.metadata.authors, our_book.metadata.authors);
    assert_eq!(calibre_book.spine.len(), our_book.spine.len());
    assert_eq!(calibre_book.toc.len(), our_book.toc.len());
}

// ============================================================================
// Performance / Stress Tests
// ============================================================================

#[test]
fn test_read_write_multiple_times() {
    let temp_dir = TempDir::new().expect("Failed to create temp dir");
    let mut path = fixture_path("simple.epub");

    // Read and write 5 times
    for i in 0..5 {
        let book = read_epub(&path).expect(&format!("Failed to read iteration {}", i));
        let new_path = temp_dir.path().join(format!("iter_{}.epub", i));
        write_epub(&book, &new_path).expect(&format!("Failed to write iteration {}", i));
        path = new_path.to_string_lossy().to_string();
    }

    // Final book should still be valid
    let final_book = read_epub(&path).expect("Failed to read final iteration");
    assert_eq!(final_book.metadata.title, "Simple Test Book");
}
